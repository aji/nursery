// Copyright (c) 2015 Alex Iadicicco <alex@ajitek.net>
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// paren.h -- main Paren header
// Copyright (C) 2015 Alex Iadicicco

// A note about reference counting:
//
//   Recursive structures are not possible to represent with plain
//   S-expressions, and cannot be created in an environment that doesn't allow
//   in-place updates of structures. Eventually a proper mark-and-sweep GC will
//   be added to keep cycles from being a problem, but refcounting is a great
//   accompaniment to such a GC for keeping memory use low. (The mere
//   evaluation of an expression will create several objects, so it's important
//   to be able to throw these away as soon as possible).
//
//   It's important to establish refcounting rules before proceeding to make
//   it easier to analyze refcounting practices. We are concerned with the ways
//   references move around the program.
//
//      o  Arguments to a function will always have 1 reference associated with
//         them. DECREF() these if you are not going to keep them.
//
//      o  Return values from a function will always have 1 reference associated
//         with them. DECREF() these if you are not going to keep them.
//
//      o  Newly constructed values will always have 1 reference associated with
//         them.
//
//   Remember to always err on the side of INCREF. If an object ends up with a
//   bad reference count, it should always be the case that references are
//   overrepresented than underrepresented. Objects that are truly unreachable
//   will be reclaimed by the mark-and-sweep GC (when implemented).

#ifndef __INC_PAREN_H__
#define __INC_PAREN_H__

#include <stdlib.h>
#include <stdarg.h>
#include <string.h>

// These macros are just to make it easier to replace the allocator in the
// future, if that's deemed necessary.
#define amalloc(s)    malloc(s)
#define acalloc(n,s)  calloc(n,s)

typedef struct String String;
typedef struct Node Node;
typedef void (InternalDtor)(void*);
typedef enum NodeTag NodeTag;
typedef struct ListBuilder ListBuilder;
typedef enum Token Token;
typedef struct ReReadBuffer ReReadBuffer;
typedef enum LexState LexState;
typedef struct ReReadContext ReReadContext;
typedef struct ReReadStack ReReadStack;
typedef struct HashMap HashMap;
typedef struct HashRow HashRow;
typedef struct EvalContext EvalContext;
typedef struct EvalScope EvalScope;

#define PERMANENT (-60)

// Strings
// ===========================================================================

struct String {
	char *buf;
	unsigned len;
	int refs;
};

extern String *pa_str_clone(String *s);
extern void pa_str_free(String *s);
extern String *pa_str_from_cstr(char *s);
extern String *pa_str_from_buf(char *s, size_t len);
extern char pa_str_char_at(String *s, int n);

// Structures
// ===========================================================================

// The lisp world is made out of Nodes. Nodes are either atoms (symbols,
// numbers, etc.) or cons cells, which are just a pair of Nodes. Together, all
// the constructs of Paren are possible.
struct Node {
	// `tag` tells us what kind of Node this is. The first 2 are special,
	// and cannot directly be generated by user code.
	enum NodeTag {
		T_NIL,
		T_INTERNAL,
		T_BUILTIN,
		T_SPECIAL,

		T_CLOSURE,

		T_CONS,
		T_ATOM,
		T_INTEGER,
		T_CHARACTER,
		T_STRSLICE,
		T_EXCEPTION,
	} tag;

	// This anonymous union contains any associated values.
	union {
		void *p;

		struct {
			void *p;
			void *kind;
			InternalDtor *dtor;
		} raw;

		Node *(*fn)(EvalContext*, Node*);
		Node *(*spec)(EvalContext*, EvalScope*, Node*, EvalScope**);

		struct {
			Node *car;
			Node *cdr;
		} cons;

		struct {
			Node *args;
			Node *body;
			EvalScope *sc;
		} cl;

		char *s;

		struct {
			String *s;
			int start;
			int len;
		} str;

		long v;

		struct {
			String *msg;
		} exc;
	};

	int refs;
};

extern const char *pa_tag_names[];

extern Node *NIL, *T;
#define COND(x) ((x) ? T : NIL)

extern int pa_allocs;
extern int pa_frees;

extern void pa_node_delete(Node *n);
extern Node *pa_exc(const char *fmt, ...);

static inline Node *INCREF(Node *n) {
	if (!n || n->refs == PERMANENT)
		return n;

	n->refs++;

	return n;
}

static inline Node *DECREF(Node *n) {
	if (!n || n->refs == PERMANENT)
		return n;

	n->refs--;
	if (n->refs <= 0)
		pa_node_delete(n);

	return n;
}

static inline Node *NODE(NodeTag tag) {
	Node *n = acalloc(1, sizeof(*n));
	pa_allocs++;
	n->tag = tag;
	n->refs = 1;
	return n;
}

static inline Node *INTERNAL(void *kind, void *p, InternalDtor *dtor) {
	Node *n = NODE(T_INTERNAL);
	n->raw.p = p;
	n->raw.kind = kind;
	n->raw.dtor = dtor;
	return n;
}

static inline Node *BUILTIN(Node *(*fn)(EvalContext*, Node*)) {
	Node *n = NODE(T_BUILTIN);
	n->fn = fn;
	return n;
}

static inline Node *SPECIAL(Node *(*fn)(EvalContext*, EvalScope*,
                                        Node*, EvalScope**)) {
	Node *n = NODE(T_SPECIAL);
	n->spec = fn;
	return n;
}

static inline Node *EXCEPTION(String *msg) {
	Node *n = NODE(T_EXCEPTION);
	n->exc.msg = msg;
	return n;
}

static inline Node *ATOM(char *s) {
	Node *n = NODE(T_ATOM);
	n->s = strdup(s);
	return n;
}

static inline Node *INT(long v) {
	Node *n = NODE(T_INTEGER);
	n->v = v;
	return n;
}

static inline Node *CHAR(char c) {
	Node *n = NODE(T_CHARACTER);
	n->v = (unsigned) c;
	return n;
}

static inline Node *STR(String *s) {
	Node *n = NODE(T_STRSLICE);
	n->str.s = s;
	n->str.start = 0;
	n->str.len = n->str.s->len;
	return n;
}

#define IS_NIL(n)   (!(n) || (n)->tag == T_NIL)
#define IS_CONS(n)  ( (n) && (n)->tag == T_CONS)

static inline Node *CAR(Node *n) {
	return IS_CONS(n) ? n->cons.car : NIL;
}

static inline Node *CDR(Node *n) {
	return IS_CONS(n) ? n->cons.cdr : NIL;
}

static inline Node *XCAR(Node *n) {
	Node *res = INCREF(CAR(n));
	DECREF(n);
	return res;
}

static inline Node *XCDR(Node *n) {
	Node *res = INCREF(CDR(n));
	DECREF(n);
	return res;
}

#define CAAR(n) CAR(CAR(n))
#define CADR(n) CAR(CDR(n))
#define CDAR(n) CDR(CAR(n))
#define CDDR(n) CDR(CDR(n))

#define CAAAR(n) CAR(CAR(CAR(n)))
#define CAADR(n) CAR(CAR(CDR(n)))
#define CADAR(n) CAR(CDR(CAR(n)))
#define CADDR(n) CAR(CDR(CDR(n)))
#define CDAAR(n) CDR(CAR(CAR(n)))
#define CDADR(n) CDR(CAR(CDR(n)))
#define CDDAR(n) CDR(CDR(CAR(n)))
#define CDDDR(n) CDR(CDR(CDR(n)))

#define CAAAAR(n) CAR(CAR(CAR(CAR(n))))
#define CAAADR(n) CAR(CAR(CAR(CDR(n))))
#define CAADAR(n) CAR(CAR(CDR(CAR(n))))
#define CAADDR(n) CAR(CAR(CDR(CDR(n))))
#define CADAAR(n) CAR(CDR(CAR(CAR(n))))
#define CADADR(n) CAR(CDR(CAR(CDR(n))))
#define CADDAR(n) CAR(CDR(CDR(CAR(n))))
#define CADDDR(n) CAR(CDR(CDR(CDR(n))))
#define CDAAAR(n) CDR(CAR(CAR(CAR(n))))
#define CDAADR(n) CDR(CAR(CAR(CDR(n))))
#define CDADAR(n) CDR(CAR(CDR(CAR(n))))
#define CDADDR(n) CDR(CAR(CDR(CDR(n))))
#define CDDAAR(n) CDR(CDR(CAR(CAR(n))))
#define CDDADR(n) CDR(CDR(CAR(CDR(n))))
#define CDDDAR(n) CDR(CDR(CDR(CAR(n))))
#define CDDDDR(n) CDR(CDR(CDR(CDR(n))))

#define XCAAR(n) XCAR(XCAR(n))
#define XCADR(n) XCAR(XCDR(n))
#define XCDAR(n) XCDR(XCAR(n))
#define XCDDR(n) XCDR(XCDR(n))

#define XCAAAR(n) XCAR(XCAR(XCAR(n)))
#define XCAADR(n) XCAR(XCAR(XCDR(n)))
#define XCADAR(n) XCAR(XCDR(XCAR(n)))
#define XCADDR(n) XCAR(XCDR(XCDR(n)))
#define XCDAAR(n) XCDR(XCAR(XCAR(n)))
#define XCDADR(n) XCDR(XCAR(XCDR(n)))
#define XCDDAR(n) XCDR(XCDR(XCAR(n)))
#define XCDDDR(n) XCDR(XCDR(XCDR(n)))

#define XCAAAAR(n) XCAR(XCAR(XCAR(XCAR(n))))
#define XCAAADR(n) XCAR(XCAR(XCAR(XCDR(n))))
#define XCAADAR(n) XCAR(XCAR(XCDR(XCAR(n))))
#define XCAADDR(n) XCAR(XCAR(XCDR(XCDR(n))))
#define XCADAAR(n) XCAR(XCDR(XCAR(XCAR(n))))
#define XCADADR(n) XCAR(XCDR(XCAR(XCDR(n))))
#define XCADDAR(n) XCAR(XCDR(XCDR(XCAR(n))))
#define XCADDDR(n) XCAR(XCDR(XCDR(XCDR(n))))
#define XCDAAAR(n) XCDR(XCAR(XCAR(XCAR(n))))
#define XCDAADR(n) XCDR(XCAR(XCAR(XCDR(n))))
#define XCDADAR(n) XCDR(XCAR(XCDR(XCAR(n))))
#define XCDADDR(n) XCDR(XCAR(XCDR(XCDR(n))))
#define XCDDAAR(n) XCDR(XCDR(XCAR(XCAR(n))))
#define XCDDADR(n) XCDR(XCDR(XCAR(XCDR(n))))
#define XCDDDAR(n) XCDR(XCDR(XCDR(XCAR(n))))
#define XCDDDDR(n) XCDR(XCDR(XCDR(XCDR(n))))

static inline Node *CONS(Node *car, Node *cdr) {
	Node *n = NODE(T_CONS);
	n->cons.car = car;
	n->cons.cdr = cdr;
	return n;
}

#define LIST1(a)             CONS(a, NIL)
#define LIST2(a,b)           CONS(a, LIST1(b))
#define LIST3(a,b,c)         CONS(a, LIST2(b,c))
#define LIST4(a,b,c,d)       CONS(a, LIST3(b,c,d))
#define LIST5(a,b,c,d,e)     CONS(a, LIST4(b,c,d,e))
#define LIST6(a,b,c,d,e,f)   CONS(a, LIST5(b,c,d,e,f))

static inline Node *LIST(Node *a, ...) {
	Node *head, *tail;
	va_list va;

	va_start(va, a);

	head = CONS(a, NIL);
	tail = head;

	for (;;) {
		a = va_arg(va, void*);
		if (IS_NIL(a))
			break;
		tail->cons.cdr = CONS(a, NIL);
		tail = CDR(tail);
	}

	return head;
}

struct ListBuilder {
	Node *head, *tail;
};

extern void pa_lb_init(ListBuilder*);
extern Node *pa_lb_finish(ListBuilder*);
extern void pa_lb_append(ListBuilder*, Node*);

// Printer
// ===========================================================================

extern void pa_print(Node *n);

// Re-entrant Reader
// ===========================================================================

enum Token {
	TK_INVALID,
	TK_EOF,
	TK_BREAK,

	TK_LPAREN,
	TK_RPAREN,
	TK_QUOTE,
	TK_DOT,
	TK_ATOM,
	TK_NUMBER,
	TK_STRING,
	TK_CHARACTER,
};

enum LexState {
	LEX_TOP,
	LEX_EOL_COMMENT,
	LEX_GRAB,
	LEX_IDENTIFY,
	LEX_STRING,
	LEX_STRING_ESC,
};

struct ReReadBuffer {
	char *data;
	unsigned len;
	unsigned pos;

	ReReadBuffer *next;
};

struct ReReadContext {
	ReReadBuffer *head;
	ReReadBuffer *tail;
	int eof_signaled;

	int unchar;
	char tokstr[4096];
	unsigned tokpos;
	LexState lexstate;
	Token untok;

	ReReadStack *stack;
};

extern void pa_reread_init(ReReadContext*);
extern void pa_reread_put(ReReadContext*, char *buf, unsigned len);
extern void pa_reread_eof(ReReadContext*);
extern int pa_reread_empty(ReReadContext*);
extern int pa_reread_finished(ReReadContext*);
extern Node *pa_reread(ReReadContext*);

// Hash Table
// ===========================================================================

struct HashMap {
	HashRow **table;
	unsigned size;
};

extern HashMap *pa_hash_new(void);
extern void pa_hash_delete(HashMap*);
extern void pa_hash_put(HashMap*, char*, Node*);
extern Node *pa_hash_get(HashMap*, char*);

// Evaluation
// ===========================================================================

struct EvalContext {
	HashMap *global;
	HashMap *modules;
};

struct EvalScope {
	HashMap *data;
	EvalScope *up;

	int refs;
};

extern HashMap *pa_builtins;

extern void pa_eval_init(EvalContext*);
extern void pa_add_module(EvalContext*, EvalContext*, char*);
extern Node *pa_lookup(EvalContext*, EvalScope*, char*);
extern Node *pa_apply(EvalContext*, Node *fn, Node *args, EvalScope**);
extern Node *pa_eval(EvalContext*, Node*);

// Standard modules
// ===========================================================================

#ifndef PAREN_NO_STD_MODULES

extern void pa_set_args(int argc, char **argv);
extern EvalContext *pa_mod_core(void);
extern EvalContext *pa_mod_io(void);
extern EvalContext *pa_mod_net(void);

#endif // PAREN_NO_STD_MODULES

#endif
